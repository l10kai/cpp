# 刷题心得体会



 ### 二分

> 二分是一开始就学习的基础算法之一，是最常用的算法之一，其基本模板有两种：、
>
> ```cpp
> //模板一
> int l =0 ,r = n;
> while(l < r){
>     int mid = l + r >> 1;
>     if(check()) r =mid;
>     else l = mid + 1;
> }
> //模板二
> int l = 0 , r = n;
> while(l < r){
>     int mid = l + r +1>> 1;
>     if(check()) l = mid;
>     else r = mid - 1;
> }
> ```
>
> 模板非常好记，但是近期在具体题目中经常出现对二分模板混淆使用导致的一系列不应该的错误。
>
> 一句话，**模板1找答案时会尽量往左边找，就会找到该数的起始位置；而模板2找答案时会尽往右边找，就会找到该数的终止位置。**



### 输入相关

```cin``` 无法直接输入带有空格的字符串，需要使用如  ```  getline(a,cin)  cin.get(a,num) cin.getline(a,num) gets_s(a)//a为字符串，num为字符串长度 ```   

**注意所有字符串的输入(包括cin.get()、cin.getline()、getline、gets_s)，如果接在cin>>a输入流后，中间必须增加cin.ignore()用以吞掉换行符**

可用``` getline() getchar() cin.ignore() cin.get() ```吞掉换行



### MAP

map中有一个键值对（key,value）

常见用法：

```cpp
map<string,int> mp;
string str = "";
mp[str]++;

if(mp[])
...
```



### LIST

list表示的是一个**双向带头循环链表**，允许在常数范围内的任意位置进行插入和删除，且前后可以进行双向迭代。其缺陷和链表一样就是不能支持随机访问（下标访问），但是在任意位置进行插入的效率更高。

* **创建变量 **

list的创建跟vector类似

在创建变量之前别忘记包含list的头文件。

```cpp
	list<int> l1;//创建一个空对象
	list<int> l2(3, 1);//创建一个包含3个1的对象
	list<int> l3(l2);//拷贝构造
	list<int> l4(l3.begin()++, l3.end()--);//在l3.begin()与l3.end()之间创造对象
```

**list与其他序列容器相比，list和forward_list最大的缺陷是不支持任意位置的访问 ，只能通过迭代实现访问**

迭代方法：``` list<int>::iterator It = l5.begin(); ```

#### list与vector的对比

vector与list都是STL中非常重要的序列式容器，由于两个容器的底层结构不同，导致其特性以及应用场景不同，其主要不同如下：

|            | vector                                                       | list                                                         |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 底层结构   | 动态顺序表，一段连续空间                                     | 带头节点的双向循环链表                                       |
| 随机访问   | 支持随机访问，访问某个元素效率O(1)                           | 不支持随机访问，访问某个元素效率O(N)                         |
| 插入和删除 | 任意位置插入和删除效率低，需要搬移元素，时间复杂度为O(N)，插入时可能需要增容。增容：开辟新空间，拷贝元素，释放旧空间，导致效率更低 | 任意位置插入和删除效率高，不需要搬移元素，时间复杂度为O(1)，不存在增容问题 |
| 空间利用率 | 底层为连续空间，不容易造成内存碎片，空间利用率高，缓存利用率高 | 底层节点随机动态开辟，小节点容易造成内存碎片，空间利用率低，缓存利用率低 |
| 迭代器     | 原生态指针                                                   | 对原生态指针（节点指针）进行封装                             |
| 迭代器失效 | 在插入元素时，要给所有的迭代器重新赋值，因为插入元素有可能会导致重新扩容，致使原来迭代器失效，删除时，当前迭代器需要重新赋值否则会失效 | 插入元素不会导致迭代器失效，删除元素时，只会导致当前迭代器失效，其他迭代器不受影响 |
| 使用场景   | 需要高效存储，支持随机访问，不关心插入删除效率               | 大量插入删除操作，不关心随机访问                             |



### 保留小数点后n位

```cpp
#include <iostream>
#include <iomanip>

using namespace std;

int main(){
    double a;
    int n;
    cin >>a>> n;
    cout << fixed << setprecision(n)<<a<<endl;
    cout <<showpoint<<setprecision(n)<<a;
}
```



   ### mex(l, r)

$ XOR(0, x) = \begin{cases} x & \text{if } x \equiv 0 \pmod{4} \\ 1 & \text{if } x \equiv 1 \pmod{4} \\ x + 1 & \text{if } x \equiv 2 \pmod{4} \\ 0 & \text{if } x \equiv 3 \pmod{4} \end{cases}$ 